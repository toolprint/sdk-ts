// This file is auto-generated by @hey-api/openapi-ts

export const ValidationErrorSchema = {
  properties: {
    loc: {
      items: {
        anyOf: [
          {
            type: 'string'
          },
          {
            type: 'integer'
          }
        ]
      },
      title: 'Location',
      type: 'array'
    },
    msg: {
      title: 'Message',
      type: 'string'
    },
    type: {
      title: 'Error Type',
      type: 'string'
    }
  },
  required: ['loc', 'msg', 'type'],
  title: 'ValidationError',
  type: 'object'
} as const

export const UserAccountSchema = {
  description: 'Model for storing user information including their API key',
  properties: {
    api_key: {
      title: 'Api Key',
      type: 'string'
    },
    belongs_to_organization_id: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Belongs To Organization Id'
    },
    created_at: {
      anyOf: [
        {
          format: 'date-time',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Created At'
    },
    doppler_service_token_id: {
      anyOf: [
        {
          format: 'uuid',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Doppler Service Token Id'
    },
    id: {
      title: 'Id',
      type: 'string'
    },
    updated_at: {
      anyOf: [
        {
          format: 'date-time',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Updated At'
    }
  },
  required: ['id', 'api_key'],
  title: 'UserAccount',
  type: 'object'
} as const

export const UpsertSecretResponseSchema = {
  properties: {
    secret_name: {
      title: 'Secret Name',
      type: 'string'
    },
    success: {
      title: 'Success',
      type: 'boolean'
    }
  },
  required: ['success', 'secret_name'],
  title: 'UpsertSecretResponse',
  type: 'object'
} as const

export const UpsertSecretRequestSchema = {
  properties: {
    value: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'object'
        }
      ],
      title: 'Value'
    },
    value_type: {
      enum: ['string', 'object'],
      title: 'Value Type',
      type: 'string'
    }
  },
  required: ['value_type', 'value'],
  title: 'UpsertSecretRequest',
  type: 'object'
} as const

export const ToolprintToolReferenceSchema = {
  description: `A reference to a tool that is used in a toolprint. This reference can link to a tool directly by a unique identifier or indirectly through
a link to the tool server as well as the name of the tool. The latter reference is experimental and relies on the implementor
to ensure that the reference is correctly followed.`,
  properties: {
    id: {
      anyOf: [
        {
          format: 'uuid',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      description: 'An optional reference id',
      title: 'Id'
    },
    name: {
      description:
        'The name of the tool. If the tool exists within this server or integration, this value will be used to link to it.',
      title: 'Name',
      type: 'string'
    },
    ref_type: {
      anyOf: [
        {
          enum: ['local', 'id'],
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      default: 'local',
      description:
        'The type of reference to the tool. If the tool exists within this server or integration, this value will be used to link to it.',
      title: 'Ref Type'
    }
  },
  required: ['name'],
  title: 'ToolprintToolReference',
  type: 'object'
} as const

export const ToolprintToolSchema = {
  description: `A definition of how a specific tool should be used within a toolprint.
This is a simplified model that focuses on the conceptual structure and specifically
avoids referential fields to any persisted entities.

This tool reference is limited to the server or integration in which the toolprint was defined.`,
  properties: {
    ref: {
      $ref: '#/components/schemas/ToolprintToolReference',
      description:
        'A reference to a tool that is used in this toolprint. This reference can link to a tool directly by a unique identifier or indirectly througha link to the tool server as well as the name of the tool. The latter reference is experimental and relies on the implementorto ensure that the reference is correctly followed.'
    },
    usage_hints: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      description:
        'A more in-depth description of this tool and what it should be used for in the context of this recipe.',
      title: 'Usage Hints'
    }
  },
  required: ['ref'],
  title: 'ToolprintTool',
  type: 'object'
} as const

export const ToolprintRecommendationSchema = {
  description: 'A recommendation for a toolprint based on a goal.',
  properties: {
    meta: {
      $ref: '#/components/schemas/SearchResultMeta',
      description: 'Meta fields for the toolprint recommendation.'
    },
    prompts: {
      description:
        "The prompts that should be injected into the message stack to prime the agent's LLM.",
      items: {
        $ref: '#/components/schemas/Prompt'
      },
      title: 'Prompts',
      type: 'array'
    },
    toolprint: {
      $ref: '#/components/schemas/RegisteredToolprint',
      description: 'The toolprint that is recommended.'
    }
  },
  required: ['meta', 'toolprint', 'prompts'],
  title: 'ToolprintRecommendation',
  type: 'object'
} as const

export const RegisteredToolprintSchema = {
  description: 'A toolprint.',
  properties: {
    created_at: {
      anyOf: [
        {
          format: 'date-time',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Created At'
    },
    created_by: {
      title: 'Created By',
      type: 'string'
    },
    id: {
      format: 'uuid',
      title: 'Id',
      type: 'string'
    },
    owner_id: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Owner Id'
    },
    source: {
      title: 'Source',
      type: 'object'
    },
    source_checksum: {
      description:
        'The checksum of the source toolprint. This helps us track changes from the original vending server/integration.',
      title: 'Source Checksum',
      type: 'string'
    },
    toolprint: {
      $ref: '#/components/schemas/Toolprint-Output',
      description:
        'Useful field for converting our persisted toolprint into a raw toolprint definition for dissemination.',
      readOnly: true
    },
    tools: {
      items: {
        $ref: '#/components/schemas/Tool'
      },
      readOnly: true,
      title: 'Tools',
      type: 'array'
    },
    updated_at: {
      anyOf: [
        {
          format: 'date-time',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Updated At'
    },
    updated_by: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Updated By'
    }
  },
  required: ['source_checksum', 'tools', 'toolprint'],
  title: 'RegisteredToolprint',
  type: 'object'
} as const

export const ToolSchema = {
  description: 'A tool.',
  properties: {
    description: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      description: 'A description of the tool.',
      title: 'Description'
    },
    icon_url: {
      anyOf: [
        {
          format: 'uri',
          minLength: 1,
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      description: 'A URL to an icon for the tool.',
      title: 'Icon Url'
    },
    id: {
      format: 'uuid',
      title: 'Id',
      type: 'string'
    },
    input_schema: {
      anyOf: [
        {
          type: 'object'
        },
        {
          type: 'boolean'
        }
      ],
      default: true,
      description:
        "A JSON schema for the tool's input (defaults to 'always valid').",
      title: 'Input Schema'
    },
    name: {
      description: 'The name of the tool (should be unique within a server).',
      title: 'Name',
      type: 'string'
    },
    server_id: {
      format: 'uuid',
      title: 'Server Id',
      type: 'string'
    }
  },
  required: ['server_id', 'name', 'id'],
  title: 'Tool',
  type: 'object'
} as const

export const Toolprint_OutputSchema = {
  description: `A declarative definition of a toolprint that describes how tools should be used together
to achieve a goal. This is a simplified model that focuses on the conceptual structure and specifically
avoids referential fields to any persisted entities.`,
  properties: {
    goal: {
      description: 'The goal that this recipe is helping an agent achieve.',
      title: 'Goal',
      type: 'string'
    },
    instructions: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      description: 'The instructions on how this recipe should be used.',
      title: 'Instructions'
    },
    meta: {
      $ref: '#/components/schemas/ToolprintMeta-Output',
      description: 'Meta fields for the toolprint.'
    },
    tools: {
      description:
        'Definitions for how each tool should be used in this toolprint.',
      items: {
        $ref: '#/components/schemas/ToolprintTool'
      },
      title: 'Tools',
      type: 'array'
    }
  },
  required: ['meta', 'goal', 'instructions', 'tools'],
  title: 'Toolprint',
  type: 'object'
} as const

export const ToolprintMeta_OutputSchema = {
  description: 'A set of meta fields that are common to all toolprints.',
  properties: {
    language: {
      const: 'en-US',
      default: 'en-US',
      description: 'The language of the toolprint.',
      title: 'Language',
      type: 'string'
    },
    name: {
      description: 'The name of the toolprint.',
      title: 'Name',
      type: 'string'
    },
    resource_id: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      description: 'The unique identifier for the toolprint.',
      title: 'Resource Id'
    },
    version: {
      default: '0.0.1',
      description: 'The version of the toolprint definition.',
      title: 'Version',
      type: 'string'
    }
  },
  required: ['name'],
  title: 'ToolprintMeta',
  type: 'object'
} as const

export const PromptSchema = {
  description: 'A prompt for an LLM.',
  properties: {
    message: {
      title: 'Message',
      type: 'string'
    },
    type: {
      enum: ['system', 'user'],
      title: 'Type',
      type: 'string'
    }
  },
  required: ['type', 'message'],
  title: 'Prompt',
  type: 'object'
} as const

export const SearchResultMetaSchema = {
  description:
    'Metadata about a search result. All search result types should inherit from this model.',
  properties: {
    score: {
      description: 'The score of the search result.',
      title: 'Score',
      type: 'number'
    }
  },
  required: ['score'],
  title: 'SearchResultMeta',
  type: 'object'
} as const

export const ToolprintMeta_InputSchema = {
  description: 'A set of meta fields that are common to all toolprints.',
  properties: {
    language: {
      const: 'en-US',
      default: 'en-US',
      description: 'The language of the toolprint.',
      title: 'Language',
      type: 'string'
    },
    name: {
      description: 'The name of the toolprint.',
      title: 'Name',
      type: 'string'
    },
    resource_id: {
      anyOf: [
        {
          format: 'uuid',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      description: 'The unique identifier for the toolprint.',
      title: 'Resource Id'
    },
    version: {
      default: '0.0.1',
      description: 'The version of the toolprint definition.',
      title: 'Version',
      type: 'string'
    }
  },
  required: ['name'],
  title: 'ToolprintMeta',
  type: 'object'
} as const

export const Toolprint_InputSchema = {
  description: `A declarative definition of a toolprint that describes how tools should be used together
to achieve a goal. This is a simplified model that focuses on the conceptual structure and specifically
avoids referential fields to any persisted entities.`,
  properties: {
    goal: {
      description: 'The goal that this recipe is helping an agent achieve.',
      title: 'Goal',
      type: 'string'
    },
    instructions: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      description: 'The instructions on how this recipe should be used.',
      title: 'Instructions'
    },
    meta: {
      $ref: '#/components/schemas/ToolprintMeta-Input',
      description: 'Meta fields for the toolprint.'
    },
    tools: {
      description:
        'Definitions for how each tool should be used in this toolprint.',
      items: {
        $ref: '#/components/schemas/ToolprintTool'
      },
      title: 'Tools',
      type: 'array'
    }
  },
  required: ['meta', 'goal', 'instructions', 'tools'],
  title: 'Toolprint',
  type: 'object'
} as const

export const ToolServerProviderSchema = {
  properties: {
    id: {
      format: 'uuid',
      title: 'Id',
      type: 'string'
    },
    name: {
      title: 'Name',
      type: 'string'
    }
  },
  required: ['id', 'name'],
  title: 'ToolServerProvider',
  type: 'object'
} as const

export const ToolServerPropertiesSchema = {
  description: 'Properties for a tool server.',
  properties: {
    properties: {
      title: 'Properties',
      type: 'object'
    }
  },
  required: ['properties'],
  title: 'ToolServerProperties',
  type: 'object'
} as const

export const ToolServerLaunchConfigSchema = {
  description: 'The launch config for a tool server.',
  properties: {
    secret_name: {
      title: 'Secret Name',
      type: 'string'
    },
    source: {
      const: 'doppler',
      title: 'Source',
      type: 'string'
    }
  },
  required: ['source', 'secret_name'],
  title: 'ToolServerLaunchConfig',
  type: 'object'
} as const

export const ToolServerSchema = {
  properties: {
    id: {
      format: 'uuid',
      title: 'Id',
      type: 'string'
    },
    name: {
      title: 'Name',
      type: 'string'
    },
    properties: {
      title: 'Properties',
      type: 'object'
    },
    provider_id: {
      format: 'uuid',
      title: 'Provider Id',
      type: 'string'
    }
  },
  required: ['provider_id', 'name', 'id'],
  title: 'ToolServer',
  type: 'object'
} as const

export const ToolResourceSchema = {
  description:
    'A broad summary of details about a tool akin to a ToolResource.',
  properties: {
    canonical_resource: {
      $ref: '#/components/schemas/CanonicalResource',
      readOnly: true
    },
    description: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Description'
    },
    id: {
      title: 'Id',
      type: 'string'
    },
    integration_name: {
      title: 'Integration Name',
      type: 'string'
    },
    org_id: {
      title: 'Org Id',
      type: 'string'
    },
    policy: {
      $ref: '#/components/schemas/PolicyBase'
    },
    profile_id: {
      title: 'Profile Id',
      type: 'string'
    },
    properties: {
      $ref: '#/components/schemas/ToolProperties'
    },
    provider: {
      $ref: '#/components/schemas/ToolServerProvider',
      readOnly: true
    },
    server: {
      $ref: '#/components/schemas/ToolServer',
      readOnly: true
    },
    tool: {
      $ref: '#/components/schemas/Tool'
    },
    tool_name: {
      title: 'Tool Name',
      type: 'string'
    }
  },
  required: [
    'integration_name',
    'tool_name',
    'id',
    'tool',
    'org_id',
    'profile_id',
    'policy',
    'properties',
    'server',
    'provider',
    'canonical_resource'
  ],
  title: 'ToolResource',
  type: 'object'
} as const

export const ToolPropertiesSchema = {
  description: 'Properties for a tool.',
  properties: {
    tags: {
      title: 'Tags',
      type: 'object'
    }
  },
  required: ['tags'],
  title: 'ToolProperties',
  type: 'object'
} as const

export const PolicyBaseSchema = {
  description: 'Base model with shared policy fields',
  properties: {
    access_policy: {
      $ref: '#/components/schemas/AccessPolicyType'
    },
    canonical_resource_name: {
      title: 'Canonical Resource Name',
      type: 'string'
    },
    description: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Description'
    },
    event_name: {
      title: 'Event Name',
      type: 'string'
    },
    organization_id: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Organization Id'
    }
  },
  required: ['event_name', 'access_policy', 'canonical_resource_name'],
  title: 'PolicyBase',
  type: 'object'
} as const

export const AccessPolicyTypeSchema = {
  description: 'Enum for access policy types',
  enum: ['ALWAYS', 'NEVER', 'REQUIRES_PERMISSION'],
  title: 'AccessPolicyType',
  type: 'string'
} as const

export const CanonicalResourceSchema = {
  description: 'Represents a canonical resource name in object form.',
  properties: {
    event_name: {
      title: 'Event Name',
      type: 'string'
    },
    org_id: {
      title: 'Org Id',
      type: 'string'
    },
    profile_id: {
      title: 'Profile Id',
      type: 'string'
    },
    server_name: {
      title: 'Server Name',
      type: 'string'
    }
  },
  required: ['org_id', 'profile_id', 'server_name', 'event_name'],
  title: 'CanonicalResource',
  type: 'object'
} as const

export const ToolCustomTagsParamsRequestSchema = {
  description: `Params to change the tags for a tool in an integration. Will upsert any tags that already
exist. Will not delete any other tags. This is only net additive.`,
  properties: {
    description: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Description'
    },
    integration_name: {
      title: 'Integration Name',
      type: 'string'
    },
    tags: {
      title: 'Tags',
      type: 'object'
    },
    tool_name: {
      title: 'Tool Name',
      type: 'string'
    }
  },
  required: ['integration_name', 'tool_name', 'tags'],
  title: 'ToolCustomTagsParamsRequest',
  type: 'object'
} as const

export const ToolCustomTagSelectionParamsRequestSchema = {
  description:
    'Params that generalize the selection the tags for a tool in an integration.',
  properties: {
    description: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Description'
    },
    integration_name: {
      title: 'Integration Name',
      type: 'string'
    },
    tags: {
      items: {
        type: 'string'
      },
      title: 'Tags',
      type: 'array'
    },
    tool_name: {
      title: 'Tool Name',
      type: 'string'
    }
  },
  required: ['integration_name', 'tool_name', 'tags'],
  title: 'ToolCustomTagSelectionParamsRequest',
  type: 'object'
} as const

export const StrategySchema = {
  description: 'A model representing a result for a goal-based search.',
  properties: {
    instructions: {
      description: 'Instructions to follow the strategy.',
      title: 'Instructions',
      type: 'string'
    },
    recipe_id: {
      description:
        'The ID of the recipe that was used to generate the strategy.',
      format: 'uuid',
      title: 'Recipe Id',
      type: 'string'
    },
    tools: {
      description:
        'List of one or more fully-hydrated tool resources that should be used in the strategy to achieve the goal.',
      items: {
        $ref: '#/components/schemas/ToolResource'
      },
      title: 'Tools',
      type: 'array'
    }
  },
  required: ['recipe_id', 'instructions', 'tools'],
  title: 'Strategy',
  type: 'object'
} as const

export const SmitheryToolServerClientSchema = {
  description: 'A client for a tool server that is a smithery server.',
  properties: {
    client_type: {
      const: 'smithery',
      title: 'Client Type',
      type: 'string'
    },
    connections: {
      items: {
        $ref: '#/components/schemas/SmitheryConnectionInfo'
      },
      title: 'Connections',
      type: 'array'
    },
    launch_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/ToolServerLaunchConfig'
        },
        {
          type: 'null'
        }
      ]
    },
    server_id: {
      format: 'uuid',
      title: 'Server Id',
      type: 'string'
    }
  },
  required: ['server_id', 'client_type', 'connections'],
  title: 'SmitheryToolServerClient',
  type: 'object'
} as const

export const SmitheryConnectionInfoSchema = {
  properties: {
    config_schema: {
      anyOf: [
        {
          type: 'object'
        },
        {
          type: 'boolean'
        }
      ],
      default: true,
      title: 'Config Schema'
    },
    deployment_url: {
      format: 'uri',
      minLength: 1,
      title: 'Deployment Url',
      type: 'string'
    },
    type: {
      enum: ['ws', 'http'],
      title: 'Type',
      type: 'string'
    }
  },
  required: ['type'],
  title: 'SmitheryConnectionInfo',
  type: 'object'
} as const

export const ServiceTokenResponseSchema = {
  description: 'Response including the service token for the SDK to use.',
  properties: {
    doppler_config: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Doppler Config'
    },
    doppler_env: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Doppler Env'
    },
    doppler_project: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Doppler Project'
    },
    doppler_service_token: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Doppler Service Token'
    }
  },
  title: 'ServiceTokenResponse',
  type: 'object'
} as const

export const SearchResponse_ScoredItem_Tool__Schema = {
  properties: {
    pagination: {
      $ref: '#/components/schemas/PaginationMetadata'
    },
    results: {
      items: {
        $ref: '#/components/schemas/ScoredItem_Tool_'
      },
      title: 'Results',
      type: 'array'
    }
  },
  required: ['pagination', 'results'],
  title: 'SearchResponse[ScoredItem[Tool]]',
  type: 'object'
} as const

export const ScoredItem_Tool_Schema = {
  properties: {
    item: {
      $ref: '#/components/schemas/Tool',
      description: 'The item that was scored.'
    },
    score: {
      description: 'The score of the item [0, 1].',
      maximum: 1,
      minimum: 0,
      title: 'Score',
      type: 'number'
    }
  },
  required: ['item', 'score'],
  title: 'ScoredItem[Tool]',
  type: 'object'
} as const

export const PaginationMetadataSchema = {
  description: 'Metadata for paginated results',
  properties: {
    has_next: {
      title: 'Has Next',
      type: 'boolean'
    },
    has_prev: {
      title: 'Has Prev',
      type: 'boolean'
    },
    page: {
      title: 'Page',
      type: 'integer'
    },
    page_size: {
      title: 'Page Size',
      type: 'integer'
    },
    pages: {
      title: 'Pages',
      type: 'integer'
    },
    total: {
      title: 'Total',
      type: 'integer'
    }
  },
  required: ['page', 'page_size', 'total', 'pages', 'has_next', 'has_prev'],
  title: 'PaginationMetadata',
  type: 'object'
} as const

export const SearchResponse_ScoredItem_RegisteredToolprint__Schema = {
  properties: {
    pagination: {
      $ref: '#/components/schemas/PaginationMetadata'
    },
    results: {
      items: {
        $ref: '#/components/schemas/ScoredItem_RegisteredToolprint_'
      },
      title: 'Results',
      type: 'array'
    }
  },
  required: ['pagination', 'results'],
  title: 'SearchResponse[ScoredItem[RegisteredToolprint]]',
  type: 'object'
} as const

export const ScoredItem_RegisteredToolprint_Schema = {
  properties: {
    item: {
      $ref: '#/components/schemas/RegisteredToolprint',
      description: 'The item that was scored.'
    },
    score: {
      description: 'The score of the item [0, 1].',
      maximum: 1,
      minimum: 0,
      title: 'Score',
      type: 'number'
    }
  },
  required: ['item', 'score'],
  title: 'ScoredItem[RegisteredToolprint]',
  type: 'object'
} as const

export const SearchRequestSchema = {
  description: 'A request for a search.',
  properties: {
    k: {
      default: 10,
      description: 'The number of results to return from index.',
      title: 'K',
      type: 'integer'
    },
    min_score: {
      default: 0,
      description: 'The minimum score to return from index.',
      title: 'Min Score',
      type: 'number'
    },
    page: {
      default: 0,
      description: 'The page number to return.',
      title: 'Page',
      type: 'integer'
    },
    page_size: {
      default: 10,
      description: 'The number of results per page.',
      title: 'Page Size',
      type: 'integer'
    },
    query: {
      description: 'The query used against the search index.',
      title: 'Query',
      type: 'string'
    }
  },
  required: ['query'],
  title: 'SearchRequest',
  type: 'object'
} as const

export const RecipeSchema = {
  description: 'A recipe.',
  properties: {
    created_at: {
      anyOf: [
        {
          format: 'date-time',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Created At'
    },
    goal: {
      description: 'The goal that this recipe is helping an agent achieve.',
      title: 'Goal',
      type: 'string'
    },
    id: {
      format: 'uuid',
      title: 'Id',
      type: 'string'
    },
    instructions: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      description: 'The instructions for this recipe.',
      title: 'Instructions'
    },
    tools: {
      items: {
        $ref: '#/components/schemas/Tool'
      },
      readOnly: true,
      title: 'Tools',
      type: 'array'
    },
    updated_at: {
      anyOf: [
        {
          format: 'date-time',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Updated At'
    }
  },
  required: ['goal', 'instructions', 'tools'],
  title: 'Recipe',
  type: 'object'
} as const

export const PolicyCheckResultSchema = {
  description: 'Result of a policy check',
  properties: {
    approved: {
      title: 'Approved',
      type: 'boolean'
    }
  },
  required: ['approved'],
  title: 'PolicyCheckResult',
  type: 'object'
} as const

export const PolicyAccessRuleSchema = {
  description: 'Policy template that is used to create a policy.',
  properties: {
    access_policy: {
      $ref: '#/components/schemas/AccessPolicyType'
    },
    description: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Description'
    },
    event_name: {
      title: 'Event Name',
      type: 'string'
    }
  },
  required: ['event_name', 'access_policy'],
  title: 'PolicyAccessRule',
  type: 'object'
} as const

export const PolicySchema = {
  description: 'Policy model that works with both SQL and in-memory storage',
  properties: {
    access_policy: {
      $ref: '#/components/schemas/AccessPolicyType'
    },
    canonical_resource_name: {
      title: 'Canonical Resource Name',
      type: 'string'
    },
    created_at: {
      anyOf: [
        {
          format: 'date-time',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Created At'
    },
    description: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Description'
    },
    event_name: {
      title: 'Event Name',
      type: 'string'
    },
    id: {
      format: 'uuid',
      title: 'Id',
      type: 'string'
    },
    organization_id: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Organization Id'
    },
    updated_at: {
      anyOf: [
        {
          format: 'date-time',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Updated At'
    }
  },
  required: ['event_name', 'access_policy', 'canonical_resource_name'],
  title: 'Policy',
  type: 'object'
} as const

export const PaginatedResponse_AuditLog_Schema = {
  properties: {
    items: {
      items: {
        $ref: '#/components/schemas/AuditLog'
      },
      title: 'Items',
      type: 'array'
    },
    pagination: {
      $ref: '#/components/schemas/PaginationMetadata'
    }
  },
  required: ['items', 'pagination'],
  title: 'PaginatedResponse[AuditLog]',
  type: 'object'
} as const

export const AuditLogSchema = {
  description: 'Model for audit logging',
  properties: {
    action: {
      title: 'Action',
      type: 'string'
    },
    details: {
      title: 'Details',
      type: 'object'
    },
    id: {
      anyOf: [
        {
          type: 'integer'
        },
        {
          type: 'null'
        }
      ],
      title: 'Id'
    },
    performed_by: {
      default: 'system',
      title: 'Performed By',
      type: 'string'
    },
    policy_id: {
      format: 'uuid',
      title: 'Policy Id',
      type: 'string'
    },
    timestamp: {
      format: 'date-time',
      title: 'Timestamp',
      type: 'string'
    }
  },
  required: ['policy_id', 'action'],
  title: 'AuditLog',
  type: 'object'
} as const

export const OrganizationSchema = {
  properties: {
    created_at: {
      anyOf: [
        {
          format: 'date-time',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Created At'
    },
    created_by_user_id: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Created By User Id'
    },
    id: {
      title: 'Id',
      type: 'string'
    },
    open_invitation_code: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Open Invitation Code'
    },
    owner_id: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Owner Id'
    },
    updated_at: {
      anyOf: [
        {
          format: 'date-time',
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Updated At'
    }
  },
  required: ['id'],
  title: 'Organization',
  type: 'object'
} as const

export const NewPolicyRequestSchema = {
  description: `Model to create a new policy. Other policy fields are derived from the default policy for the
integration/event`,
  properties: {
    access_policy: {
      $ref: '#/components/schemas/AccessPolicyType'
    },
    event_name: {
      title: 'Event Name',
      type: 'string'
    },
    integration_name: {
      title: 'Integration Name',
      type: 'string'
    }
  },
  required: ['integration_name', 'event_name', 'access_policy'],
  title: 'NewPolicyRequest',
  type: 'object'
} as const

export const MultipleToolCustomTagsParamsRequestSchema = {
  description:
    'Params to change the tags for multiple tools in an integration.',
  properties: {
    tags: {
      title: 'Tags',
      type: 'object'
    },
    tool_names: {
      items: {
        type: 'string'
      },
      title: 'Tool Names',
      type: 'array'
    }
  },
  required: ['tool_names', 'tags'],
  title: 'MultipleToolCustomTagsParamsRequest',
  type: 'object'
} as const

export const MultiIdPostBodySchema = {
  description: 'A multi-id post body.',
  properties: {
    ids: {
      anyOf: [
        {
          items: {
            type: 'string'
          },
          type: 'array'
        },
        {
          items: {
            format: 'uuid',
            type: 'string'
          },
          type: 'array'
        }
      ],
      title: 'Ids'
    }
  },
  required: ['ids'],
  title: 'MultiIdPostBody',
  type: 'object'
} as const

export const MCPToolServerClientSchema = {
  description:
    'A client for a tool server that is a direct MCP server connection.',
  properties: {
    client_type: {
      const: 'mcp',
      title: 'Client Type',
      type: 'string'
    },
    server_id: {
      format: 'uuid',
      title: 'Server Id',
      type: 'string'
    },
    transport_type: {
      enum: ['sse', 'websocket'],
      title: 'Transport Type',
      type: 'string'
    },
    url: {
      format: 'uri',
      minLength: 1,
      title: 'Url',
      type: 'string'
    }
  },
  required: ['server_id', 'client_type', 'transport_type', 'url'],
  title: 'MCPToolServerClient',
  type: 'object'
} as const

export const MCPIntegrationArgsSchema = {
  description:
    'Arguments specifically for an integration that is powered by an MCP server.',
  properties: {
    args: {
      anyOf: [
        {
          items: {
            type: 'string'
          },
          type: 'array'
        },
        {
          type: 'null'
        }
      ],
      title: 'Args'
    },
    command: {
      title: 'Command',
      type: 'string'
    },
    type: {
      const: 'mcp',
      title: 'Type',
      type: 'string'
    }
  },
  required: ['type', 'command'],
  title: 'MCPIntegrationArgs',
  type: 'object'
} as const

export const IntegrationTemplateSchema = {
  description: `Class representation of the server templates that we support. This matches the structure
of server templates under resources/integrations/templates/*`,
  properties: {
    args: {
      discriminator: {
        mapping: {
          mcp: '#/components/schemas/MCPIntegrationArgs'
        },
        propertyName: 'type'
      },
      oneOf: [
        {
          $ref: '#/components/schemas/MCPIntegrationArgs'
        }
      ],
      title: 'Args'
    },
    auth_scheme: {
      anyOf: [
        {
          $ref: '#/components/schemas/IntegrationAuthScheme'
        },
        {
          type: 'null'
        }
      ]
    },
    default_policies: {
      $ref: '#/components/schemas/IntegrationDefaultPolicies'
    },
    name: {
      title: 'Name',
      type: 'string'
    },
    oauth_authorizer: {
      anyOf: [
        {
          $ref: '#/components/schemas/IntegrationOAuthAuthorizer'
        },
        {
          type: 'null'
        }
      ]
    },
    repository: {
      title: 'Repository',
      type: 'string'
    },
    secrets: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/IntegrationSecret'
          },
          type: 'array'
        },
        {
          type: 'null'
        }
      ],
      title: 'Secrets'
    },
    sha: {
      title: 'Sha',
      type: 'string'
    },
    version: {
      description: 'The version of the integration template.',
      title: 'Version',
      type: 'string'
    }
  },
  required: [
    'version',
    'name',
    'repository',
    'sha',
    'args',
    'default_policies'
  ],
  title: 'IntegrationTemplate',
  type: 'object'
} as const

export const IntegrationSecretSchema = {
  description: 'Represents a secret required by a server template.',
  properties: {
    generation_link: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Generation Link'
    },
    name: {
      title: 'Name',
      type: 'string'
    },
    value: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Value'
    }
  },
  required: ['name'],
  title: 'IntegrationSecret',
  type: 'object'
} as const

export const IntegrationOAuthAuthorizerSchema = {
  enum: ['google', 'meta'],
  title: 'IntegrationOAuthAuthorizer',
  type: 'string'
} as const

export const IntegrationDefaultPoliciesSchema = {
  description: 'Default policies for an integration.',
  properties: {
    tools: {
      description: 'Policies for tools in this integration.',
      items: {
        $ref: '#/components/schemas/PolicyAccessRule'
      },
      title: 'Tools',
      type: 'array'
    }
  },
  required: ['tools'],
  title: 'IntegrationDefaultPolicies',
  type: 'object'
} as const

export const IntegrationAuthSchemeSchema = {
  description: 'Authentication schemes supported by server templates.',
  enum: ['token', 'oauth_1_0', 'oauth_2_0'],
  title: 'IntegrationAuthScheme',
  type: 'string'
} as const

export const IntegrationConfigurationStateSchema = {
  description: `The state of an integration from an account perspective (not runtime).
To determine the runtime state, we will have to check the server configuration for
the integration separately depending on our infrastucture selection.`,
  enum: ['agent_local', 'cloud_hosted_available', 'cloud_hosted_configured'],
  title: 'IntegrationConfigurationState',
  type: 'string'
} as const

export const IntegrationConfigDetailsSchema = {
  description:
    'General details about an integration. Meant to be surfaceable to a client.',
  properties: {
    configuration_state: {
      $ref: '#/components/schemas/IntegrationConfigurationState'
    },
    name: {
      title: 'Name',
      type: 'string'
    },
    template: {
      $ref: '#/components/schemas/IntegrationTemplate'
    }
  },
  required: ['name', 'configuration_state', 'template'],
  title: 'IntegrationConfigDetails',
  type: 'object'
} as const

export const InitializeResponseSchema = {
  description: 'Response for the SDK to initialize.',
  properties: {
    clients: {
      items: {
        discriminator: {
          mapping: {
            blaxel: '#/components/schemas/BlaxelToolServerClient',
            composio: '#/components/schemas/ComposioToolServerClient',
            mcp: '#/components/schemas/MCPToolServerClient',
            smithery: '#/components/schemas/SmitheryToolServerClient'
          },
          propertyName: 'client_type'
        },
        oneOf: [
          {
            $ref: '#/components/schemas/MCPToolServerClient'
          },
          {
            $ref: '#/components/schemas/BlaxelToolServerClient'
          },
          {
            $ref: '#/components/schemas/SmitheryToolServerClient'
          },
          {
            $ref: '#/components/schemas/ComposioToolServerClient'
          }
        ]
      },
      title: 'Clients',
      type: 'array'
    },
    doppler_config: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Doppler Config'
    },
    doppler_env: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Doppler Env'
    },
    doppler_project: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Doppler Project'
    },
    doppler_service_token: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Doppler Service Token'
    },
    org_id: {
      title: 'Org Id',
      type: 'string'
    },
    providers: {
      items: {
        $ref: '#/components/schemas/ToolServerProvider'
      },
      title: 'Providers',
      type: 'array'
    },
    servers: {
      items: {
        $ref: '#/components/schemas/ToolServer'
      },
      title: 'Servers',
      type: 'array'
    },
    tools: {
      items: {
        $ref: '#/components/schemas/Tool'
      },
      title: 'Tools',
      type: 'array'
    },
    user_id: {
      title: 'User Id',
      type: 'string'
    }
  },
  required: ['clients', 'providers', 'servers', 'tools', 'user_id', 'org_id'],
  title: 'InitializeResponse',
  type: 'object'
} as const

export const ComposioToolServerClientSchema = {
  description: 'A client for a tool server that is a composio server.',
  properties: {
    allowed_tools: {
      items: {
        type: 'string'
      },
      title: 'Allowed Tools',
      type: 'array'
    },
    auth_config_id: {
      title: 'Auth Config Id',
      type: 'string'
    },
    client_type: {
      const: 'composio',
      title: 'Client Type',
      type: 'string'
    },
    composio_server_id: {
      title: 'Composio Server Id',
      type: 'string'
    },
    mcp_url: {
      title: 'Mcp Url',
      type: 'string'
    },
    server_id: {
      format: 'uuid',
      title: 'Server Id',
      type: 'string'
    }
  },
  required: [
    'server_id',
    'client_type',
    'composio_server_id',
    'auth_config_id',
    'allowed_tools',
    'mcp_url'
  ],
  title: 'ComposioToolServerClient',
  type: 'object'
} as const

export const BlaxelToolServerClientSchema = {
  description: 'A client for a tool server that is a blaxel server.',
  properties: {
    blaxel_function: {
      title: 'Blaxel Function',
      type: 'string'
    },
    blaxel_workspace: {
      title: 'Blaxel Workspace',
      type: 'string'
    },
    client_type: {
      const: 'blaxel',
      title: 'Client Type',
      type: 'string'
    },
    server_id: {
      format: 'uuid',
      title: 'Server Id',
      type: 'string'
    }
  },
  required: ['server_id', 'client_type', 'blaxel_workspace', 'blaxel_function'],
  title: 'BlaxelToolServerClient',
  type: 'object'
} as const

export const HTTPValidationErrorSchema = {
  properties: {
    detail: {
      items: {
        $ref: '#/components/schemas/ValidationError'
      },
      title: 'Detail',
      type: 'array'
    }
  },
  title: 'HTTPValidationError',
  type: 'object'
} as const

export const GetAllFlagsResponseSchema = {
  properties: {
    flags: {
      additionalProperties: {
        anyOf: [
          {
            type: 'boolean'
          },
          {
            type: 'string'
          }
        ]
      },
      title: 'Flags',
      type: 'object'
    },
    user_id: {
      title: 'User Id',
      type: 'string'
    }
  },
  required: ['flags', 'user_id'],
  title: 'GetAllFlagsResponse',
  type: 'object'
} as const

export const Body_upsert_secret_api_v1_secrets__secret_name__putSchema = {
  properties: {
    request: {
      $ref: '#/components/schemas/UpsertSecretRequest'
    }
  },
  required: ['request'],
  title: 'Body_upsert_secret_api_v1_secrets__secret_name__put',
  type: 'object'
} as const

export const BasicPostResponseSchema = {
  description: 'A basic post response.',
  properties: {
    message: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'Message'
    },
    success: {
      title: 'Success',
      type: 'boolean'
    }
  },
  required: ['success'],
  title: 'BasicPostResponse',
  type: 'object'
} as const

export const BasicPostBodySchema = {
  description: 'A basic post body.',
  properties: {
    content: {
      title: 'Content',
      type: 'string'
    }
  },
  required: ['content'],
  title: 'BasicPostBody',
  type: 'object'
} as const

export const AuthenticationStatusSchema = {
  properties: {
    credentials_provided: {
      title: 'Credentials Provided',
      type: 'boolean'
    },
    is_authenticated: {
      title: 'Is Authenticated',
      type: 'boolean'
    },
    method: {
      anyOf: [
        {
          $ref: '#/components/schemas/AuthenticationMethod'
        },
        {
          type: 'null'
        }
      ]
    },
    user_id: {
      anyOf: [
        {
          type: 'string'
        },
        {
          type: 'null'
        }
      ],
      title: 'User Id'
    }
  },
  required: ['credentials_provided', 'is_authenticated'],
  title: 'AuthenticationStatus',
  type: 'object'
} as const

export const AuthenticationMethodSchema = {
  enum: ['propelauth', 'api_key'],
  title: 'AuthenticationMethod',
  type: 'string'
} as const

export const ApprovalAndPolicySchema = {
  description: 'Approval and policy',
  properties: {
    approval: {
      $ref: '#/components/schemas/ActionApprovalRequest'
    },
    canonical_resource_name: {
      title: 'Canonical Resource Name',
      type: 'string'
    },
    integration_name: {
      title: 'Integration Name',
      type: 'string'
    },
    policy: {
      $ref: '#/components/schemas/Policy'
    },
    tool_name: {
      title: 'Tool Name',
      type: 'string'
    }
  },
  required: [
    'approval',
    'policy',
    'canonical_resource_name',
    'integration_name',
    'tool_name'
  ],
  title: 'ApprovalAndPolicy',
  type: 'object'
} as const

export const ActionApprovalRequestSchema = {
  description: `Model that holds the state of a request for an action to be taken with respect to a policy.
Ex. if the policy is set to require approval, then we will have a request for approval.`,
  properties: {
    created_at: {
      format: 'date-time',
      title: 'Created At',
      type: 'string'
    },
    id: {
      anyOf: [
        {
          type: 'integer'
        },
        {
          type: 'null'
        }
      ],
      title: 'Id'
    },
    last_updated_at: {
      format: 'date-time',
      title: 'Last Updated At',
      type: 'string'
    },
    payload: {
      anyOf: [
        {
          type: 'object'
        },
        {
          type: 'null'
        }
      ],
      title: 'Payload'
    },
    policy_id: {
      format: 'uuid',
      title: 'Policy Id',
      type: 'string'
    },
    state: {
      $ref: '#/components/schemas/ActionApprovalState',
      default: 'pending'
    },
    updated_by_user_id: {
      title: 'Updated By User Id',
      type: 'string'
    }
  },
  required: ['id', 'policy_id', 'updated_by_user_id'],
  title: 'ActionApprovalRequest',
  type: 'object'
} as const

export const ActionApprovalStateSchema = {
  description: 'Enum for policy approval states',
  enum: ['pending', 'approved', 'rejected'],
  title: 'ActionApprovalState',
  type: 'string'
} as const

export const AccountInformationSchema = {
  description: 'Model for storing account information',
  properties: {
    account: {
      $ref: '#/components/schemas/UserAccount'
    },
    organization: {
      $ref: '#/components/schemas/Organization'
    },
    user_id: {
      title: 'User Id',
      type: 'string'
    }
  },
  required: ['user_id', 'account', 'organization'],
  title: 'AccountInformation',
  type: 'object'
} as const

export const AccountCreateRequestSchema = {
  properties: {
    email: {
      title: 'Email',
      type: 'string'
    },
    invitation_code: {
      title: 'Invitation Code',
      type: 'string'
    }
  },
  required: ['invitation_code', 'email'],
  title: 'AccountCreateRequest',
  type: 'object'
} as const
